1) Frontend: normalize datetime-local to ISO 8601 (with timezone)
File: client/src/pages/incident-reporting.tsx
The input type="datetime-local" returns strings like 2025-08-17T10:00 (no seconds, no timezone).
The backend expects ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ).
Add helper (top of file or a small util):
function localDatetimeToISO(dtLocal: string): string | undefined {
  if (!dtLocal) return undefined;
  // Normalize to full local time (assume minutes precision)
  // dtLocal: "YYYY-MM-DDTHH:mm"
  const [date, time] = dtLocal.split("T");
  if (!date || !time) return undefined;
  const [y, m, d] = date.split("-").map(Number);
  const [hh, mm] = time.split(":").map(Number);
  const asLocal = new Date(y, (m ?? 1) - 1, d ?? 1, hh ?? 0, mm ?? 0, 0, 0);
  return asLocal.toISOString(); // converts to UTC ISO with 'Z'
}
In the submit handler (before calling fetch/axios):
const payload = {
  ...values,
  incidentDateTime: localDatetimeToISO(values.incidentDateTime),
  manufacturer: values.manufacturer?.trim() || undefined,
  model: values.model?.trim() || undefined,
};
Keep the input as type="datetime-local", but send ISO in the request.
2) Backend: accept both ISO and “local-like” strings (defensive)
File: src/api/incidents.ts
Keep Zod but allow lenient strings; convert server-side to ISO if needed.
import { z } from "zod";

const IncidentCreateSchema = z.object({
  title: z.string().min(1),
  description: z.string().min(1),
  priority: z.string().min(1),
  incidentDateTime: z.string().optional(), // accept any string, normalize below
  // equipment IDs can be optional at creation (if your flow is multi-step)
  equipment_group_id: z.number().int().optional(),
  equipment_type_id: z.number().int().optional(),
  equipment_subtype_id: z.number().int().optional(),
  manufacturer: z.string().max(100).optional(),
  model: z.string().max(100).optional(),
  assetId: z.string().uuid().optional(),
  // ... other fields
});
Normalize in handler BEFORE DB write:
function toISOOrUndefined(input?: string) {
  if (!input) return undefined;
  // If already ISO and parses, keep it
  const d1 = new Date(input);
  if (!isNaN(d1.getTime()) && /\d{2}:\d{2}:\d{2}/.test(input)) return d1.toISOString();

  // If it looks like "YYYY-MM-DDTHH:mm" (no seconds), treat as local
  if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(input)) {
    const [date, time] = input.split("T");
    const [y,m,d] = date.split("-").map(Number);
    const [hh,mm] = time.split(":").map(Number);
    const local = new Date(y, (m??1)-1, d??1, hh??0, mm??0, 0, 0);
    return local.toISOString();
  }

  // Last resort: try Date parse
  const d2 = new Date(input);
  return isNaN(d2.getTime()) ? undefined : d2.toISOString();
}

// in POST handler
const body = IncidentCreateSchema.parse(req.body);
const incidentDateTimeISO = toISOOrUndefined(body.incidentDateTime);
// … use incidentDateTimeISO when inserting
If you still want strict Zod .datetime(), apply it after normalization.
3) Frontend schema & default values: stop nulls from breaking validation
File: client/src/pages/incident-reporting.tsx
Ensure defaultValues don’t contain null for numeric IDs; use undefined.
const form = useForm({
  defaultValues: {
    title: "",
    description: "",
    priority: "",
    incidentDateTime: "",         // empty string OK
    equipment_group_id: undefined, // NOT null
    equipment_type_id: undefined,
    equipment_subtype_id: undefined,
    manufacturer: "",
    model: "",
    // ...
  }
});
In your Zod/Yup form schema, make equipment_*_id optional if your flow sets them in a later step (you can enforce them at the step they are required).
4) Types: fix TS diagnostics in the form
For Select components bound to numbers, coerce on change:
onValueChange={(v) => form.setValue("equipment_group_id", v ? Number(v) : undefined)}
Add non-empty guards when submitting; if your backend requires IDs, show a user-facing validation error before posting.
5) Quick self-test (Agent should run)
Minimal POST (works)
curl -s -X POST http://localhost:5000/api/incidents \
 -H "Content-Type: application/json" \
 -H "X-User: analyst@acme.test" -H "X-Role: Analyst" \
 -d '{
  "title": "Datetime Fix",
  "description": "Testing ISO conversion",
  "priority": "Low",
  "incidentDateTime": "2025-08-17T10:00"   // frontend will convert; backend normalizes too
 }'
Expect: 200/201 with an incident id.
UI: after building, create an incident with the date-time picker; it should succeed.
6) Acceptance criteria
Submitting the Incident Reporting form no longer returns 400 because of date/time.
Request payload contains incidentDateTime in ISO 8601.
Backend stores a valid timestamp (no “Invalid Date”).
Equipment IDs can be left empty where your flow allows; no TS errors in console.
Manufacturer/Model text fields continue to persist as snapshots.