Immediate fix (no code changes yet)
1.	Clean the .env (keep exactly one 32-char secret)
ini

# .env (final)
AI_KEY_ENCRYPTION_SECRET=a9f1c5d26e7e438dab9a1efea4b74983
AVAILABLE_AI_PROVIDERS=openai,anthropic,gemini
2.	Restart clean & clear caches
bash

rm -rf .next/cache dist node_modules/.cache
npm ci
npm run build
npm start
3.	Re-test Save
‚Ä¢	Create provider with a dummy key; Save should succeed (201/200).
‚Ä¢	GET should show redacted key; DB should store ciphertext, not plaintext.
 
üõ°Ô∏è Hardening (add this once the above works)
A) Boot-time guard (fail fast if key invalid)
Add a config check that runs on server start and throws if the key isn‚Äôt exactly 32 bytes.
ts

// server/config/ai-secrets.ts
const key = process.env.AI_KEY_ENCRYPTION_SECRET ?? '';
if (key.length !== 32) {
  // Do not print key value
  throw new Error(`AI_KEY_ENCRYPTION_SECRET must be exactly 32 characters; got len=${key.length}`);
}
export const AI_SECRET_KEY = Buffer.from(key); // used by encrypt/decrypt
Ensure the encryption code imports only from this module (no direct process.env reads elsewhere).
B) Runtime guard in encrypt/decrypt (defense in depth)
ts

function ensureKeyLen(buf: Buffer) {
  if (buf.length !== 32) throw new Error('Invalid AI secret key length');
}
export function encrypt(plain: string): string {
  ensureKeyLen(AI_SECRET_KEY);
  const iv = crypto.randomBytes(16); // AES-256-CBC needs 16-byte IV
  const cipher = crypto.createCipheriv('aes-256-cbc', AI_SECRET_KEY, iv);
  const enc = Buffer.concat([cipher.update(plain, 'utf8'), cipher.final()]);
  return iv.toString('base64') + ':' + enc.toString('base64');
}
export function decrypt(blob: string): string {
  ensureKeyLen(AI_SECRET_KEY);
  const [ivB64, dataB64] = blob.split(':');
  const iv = Buffer.from(ivB64, 'base64');
  const data = Buffer.from(dataB64, 'base64');
  const decipher = crypto.createDecipheriv('aes-256-cbc', AI_SECRET_KEY, iv);
  return Buffer.concat([decipher.update(data), decipher.final()]).toString('utf8');
}
C) Health check endpoint (ops-friendly)
‚Ä¢	GET /api/ai/health returns:
o	{"keyLength":32,"activeProvider": "...", "lastCheck":"..."}
‚Ä¢	Never return secrets; only the length (32) and high-level status.
D) Tests (must pass)
‚Ä¢	Config test: process env with len 31/33 ‚Üí server should throw on boot; len 32 ‚Üí OK.
‚Ä¢	Encrypt/decrypt test: roundtrip data; ciphertext ‚â† plaintext; iv differs each call.
‚Ä¢	Save path test: POST with apiKey succeeds; GET shows redacted; DB shows ciphertext.
‚Ä¢	No-leak test: grep logs for sk-/apiKey; should return nothing.
E) CI guard against duplicate env keys (optional but recommended)
Add a tiny script to fail CI if .env contains the same key twice:
bash

# tools/check-env-dupes.sh
#!/usr/bin/env bash
set -e
dupes=$(grep -E '^[A-Z0-9_]+=' .env | cut -d= -f1 | sort | uniq -d || true)
if [ -n "$dupes" ]; then
  echo "Duplicate keys in .env: $dupes"; exit 1
fi
Run it in CI before build.
 
üìé Ask the agent to post these proofs
1.	.env diff showing the duplicate removed.
2.	Boot logs or screenshot showing the server starts clean (no key-length error).
3.	Save flow:
o	Network request payload with "apiKey":"sk-...".
o	Response 201/200.
o	Follow-up GET shows redacted key.
o	DB snapshot showing ciphertext (not the raw sk-...).
4.	Health check returns keyLength: 32.
5.	Test results for config guard, encrypt/decrypt, and no secret leaks.
6.	CI log showing the env-dupe check (if added) and green build.

